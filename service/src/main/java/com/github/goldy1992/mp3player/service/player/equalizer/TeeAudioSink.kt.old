package com.github.goldy1992.mp3player.service.dagger.modules.service

import android.os.Bundle
import android.support.v4.media.session.MediaSessionCompat
import android.util.Log
import com.github.goldy1992.mp3player.commons.AudioSample
import com.github.goldy1992.mp3player.commons.Constants.AUDIO_DATA
import com.github.goldy1992.mp3player.commons.LogTagger
import com.google.android.exoplayer2.audio.AudioProcessor
import com.google.android.exoplayer2.audio.TeeAudioProcessor
import org.apache.commons.lang3.exception.ExceptionUtils
import org.apache.commons.math3.complex.Complex
import org.apache.commons.math3.transform.DftNormalization
import org.apache.commons.math3.transform.FastFourierTransformer
import org.apache.commons.math3.transform.TransformType
import java.nio.ByteBuffer
import java.nio.ByteOrder
import javax.inject.Inject
import kotlin.math.atan2
import kotlin.math.hypot
import kotlin.math.pow

class TeeAudioSink

    @Inject
    constructor(private val mediaSessionCompat: MediaSessionCompat)
    : TeeAudioProcessor.AudioBufferSink, LogTagger {

    private var audioFormat : AudioProcessor.AudioFormat = AudioProcessor.AudioFormat.NOT_SET

    override fun flush(sampleRateHz: Int, channelCount: Int, encoding: Int) {
        this.audioFormat = AudioProcessor.AudioFormat(sampleRateHz, channelCount, encoding)
        Log.d(logTag(), "Flush called! sampleRateHz: $sampleRateHz, channelCount: $channelCount, encoding: $encoding")
    }

    override fun handleBuffer(buffer: ByteBuffer) {
        try {
            Log.d(logTag(), "ByteBuffer called: limit: ${buffer.limit()}, capacity: ${buffer.capacity()}, position: ${buffer.position()}")

            val ftt = FastFourierTransformer(DftNormalization.STANDARD)
            val sampleSize = getSampleSize(buffer.remaining()) / (audioFormat.bytesPerFrame)
            val bytes : ByteArray = ByteArray(sampleSize)
            buffer.get(bytes)
            val doubles : DoubleArray = DoubleArray(bytes.size)
            Log.d(logTag(), "bytes: ${bytes.joinToString(",")}")
            var currentDouble = 0
            var i = 0
            while (i < bytes.size - audioFormat.bytesPerFrame) {
                val bb = ByteBuffer.allocate(audioFormat.bytesPerFrame)
                bb.order(ByteOrder.LITTLE_ENDIAN)
                for (j in i .. i + audioFormat.bytesPerFrame-1) {
                    bb.put(bytes[j])
                }
                doubles[currentDouble] = bb.getDouble(0)
                currentDouble++
                i += audioFormat.bytesPerFrame
            }
            //      Log.d(logTag(), "doubles: ${doubles.joinToString(",")}")

            val ffTransformed : Array<Complex> = ftt.transform(doubles, TransformType.FORWARD)

            val phase : Array<Double> = getPhase(ffTransformed)
       //     Log.d(logTag(), "phase: ${phase.joinToString(",")}")
            val magnitude : Array<Double> = getMagnitude(ffTransformed)
         //   Log.d(logTag(), "magnitude: ${magnitude.joinToString(",")}")

            val sample = AudioSample(phase, magnitude)
            val bundle = Bundle()
            bundle.putSerializable(AUDIO_DATA, sample)
            mediaSessionCompat.sendSessionEvent(AUDIO_DATA, bundle)
        } catch (ex : Exception) {
            Log.e(logTag(), ExceptionUtils.getStackTrace(ex))
        }
    }

    override fun logTag(): String {
        return "TeeAudioSink"
    }

    private fun getMagnitude(fftData: Array<Complex>) : Array<Double> {
        return fftData.map { value -> hypot(value.real, value.imaginary) }.toTypedArray()
    }

    private fun getPhase(fftData: Array<Complex>) : Array<Double> {
        return fftData.map { value -> atan2(value.imaginary, value.real) }.toTypedArray()
    }

    private fun getSampleSize(remaining : Int) : Int {
        val base : Double = 2.0
        var power : Double = 0.0
        var found = false
        while (!found) {
            val sampleSize = base.pow(power)

            if (sampleSize > remaining) {
                found = true
                power -= 1
            } else {
                power += 1
            }
        }

        return base.pow(power).toInt()
    }
}