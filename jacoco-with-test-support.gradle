apply plugin: 'jacoco'

jacoco {
    toolVersion = "$JACOCO_VERSION"
}

def fileFilter = [
        '**/R.class',
        '**/R$*.class',
        '**/BuildConfig.*',
        '**/Manifest*.*',
        '**/*Test*.*',
        'android/**/*.*',
        '**/*$[0-9].*',
        '**/dagger/**',
        '**/databinding/**',
        '**hilt_aggregated_deps**',
        '**/Hilt_**'
]

def applicableProductFlavor = "full"

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
}

/**
 * Generates a JaCoCo Report that aggregates the test coverage for the unit tests and
 * instrumentation tests.
 */
task jacocoCombinedUnitTestAndroidTestReport(type: JacocoReport, dependsOn: ['testFullDebugUnitTest', 'connectedFullDebugAndroidTest']) {

    reports {
        xml.enabled = true
        html.enabled = true
    }

    def mainSrc = "$project.projectDir/src/main/java"
    def mainClasses = fileTree(dir: "$project.buildDir/tmp/kotlin-classes/fullDebug", excludes: fileFilter)
    def javaClasses = fileTree(dir: "${buildDir}/intermediates/javac/fullDebug", excludes: fileFilter)


    sourceDirectories.from = files([mainSrc])
    classDirectories.from = files([mainClasses, javaClasses])

    // combine unit test jacoco.exec file with the android test coverage.ec file
    executionData.from = fileTree(dir: "$projectDir", include: ["/jacoco.exec",
                                "build/outputs/code_coverage/fullDebugAndroidTest/connected/*.ec"])
}



project.afterEvaluate {
    def buildType = 'debug'

    def productFlavors = android.productFlavors.collect {
        flavor -> flavor.name
    }

    def flavor = ''
    if (!productFlavors?.isEmpty() && productFlavors.contains(applicableProductFlavor) ) {
        flavor = applicableProductFlavor
    }

    def buildVariant = ''
    if (flavor.isBlank()) {
       buildVariant = "${buildType}"
    } else {
        buildVariant = "${flavor}${buildType.capitalize()}"
    }
    def buildVariantCapitalised = buildVariant.capitalize()

    task jacocoUnitTestReport(type: JacocoReport, dependsOn: ["test${buildVariantCapitalised}UnitTest"]) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports on the ${buildVariant} build."
        reports {
            xml.enabled = true
            html.enabled = true
        }

        def mainSrc = "$project.projectDir/src/main/java"
        def mainClasses = fileTree(dir: "${buildDir}/tmp/kotlin-classes/${buildVariant}", excludes: fileFilter)
        def javaClasses = fileTree(dir: "${buildDir}/intermediates/javac/${buildVariant}", excludes: fileFilter)

        sourceDirectories.from = files([mainSrc])
        classDirectories.from = files([mainClasses, javaClasses])
        executionData.from = "$projectDir/jacoco.exec"
    }

    task jacocoCombinedUnitTestAndroidTestReport(type: JacocoReport, dependsOn: ["test${buildVariantCapitalised}UnitTest", "connected${buildVariantCapitalised}AndroidTest"]) {

        reports {
            xml.enabled = true
            html.enabled = true
        }

        def mainSrc = "$project.projectDir/src/main/java"
        def mainClasses = fileTree(dir: "$project.buildDir/tmp/kotlin-classes/fullDebug", excludes: fileFilter)
        def javaClasses = fileTree(dir: "${buildDir}/intermediates/javac/fullDebug", excludes: fileFilter)


        sourceDirectories.from = files([mainSrc])
        classDirectories.from = files([mainClasses, javaClasses])

        // combine unit test jacoco.exec file with the android test coverage.ec file
        executionData.from = fileTree(dir: "$projectDir", include: ["/jacoco.exec",
                                                                    "build/outputs/code_coverage/fullDebugAndroidTest/connected/*.ec"])
    }
}


