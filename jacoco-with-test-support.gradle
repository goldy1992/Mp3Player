apply plugin: 'jacoco'

jacoco {
    toolVersion = jacoco_version
}

def fileFilter = [
        '**/R.class',
        '**/R$*.class',
        '**/BuildConfig.*',
        '**/Manifest*.*',
        '**/*Test*.*',
        'android/**/*.*',
        '**/*$[0-9].*',
        '**/dagger/**',
        '**/databinding/**',
        '**hilt_aggregated_deps**',
        '**/Hilt_**'
]

def excludeUiCode = ['**/ui/**']


tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
}

project.afterEvaluate {

    def productFlavors = android.productFlavors.collect {
        flavor -> flavor.name
    }
    def applicableProductFlavor = "full"
    def unitTestBuildType = 'release'
    def unitTestFlavor = getProductFlavor(applicableProductFlavor, productFlavors);
    def (String unitTestBuildVariant, String unitTestBuildVariantCapitalised) = getBuildVariant(unitTestFlavor, unitTestBuildType)

    /**
     * Generates a JaCoCo Report for the test coverage for the unit tests.
     */
    task jacocoUnitTestReport(type: JacocoReport, dependsOn: ["test${unitTestBuildVariantCapitalised}UnitTest"]) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports on the ${unitTestBuildVariantCapitalised} build."
        reports {
            xml.enabled = true
            html.enabled = true
        }

        def exclusions = fileFilter + excludeUiCode
        def mainSrc = "$project.projectDir/src/main/java"

        def mainClasses = fileTree(dir: "${buildDir}/tmp/kotlin-classes/${unitTestBuildVariant}", excludes: exclusions)
        def javaClasses = fileTree(dir: "${buildDir}/intermediates/javac/${unitTestBuildVariant}", excludes: exclusions)

        sourceDirectories.from = files([mainSrc])
        classDirectories.from = files([mainClasses, javaClasses])
        executionData.from = "$buildDir/jacoco/test${unitTestBuildVariantCapitalised}UnitTest.exec"
    }


    def uiTestBuildType = 'debug'
    def uiTestFlavor = getProductFlavor(applicableProductFlavor, productFlavors);
    def (String uiTestBuildVariant, String uiTestBuildVariantCapitalised) = getBuildVariant(uiTestFlavor, uiTestBuildType)

    /**
     * Generates a JaCoCo Report for the test coverage for the UI tests.
     */
    task jacocoUiTestReport(type: JacocoReport) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for both UI and Unit Tests on the ${uiTestBuildVariantCapitalised} build."

        reports {
            xml.enabled = true
            html.enabled = true
        }

        def mainSrc = "$project.projectDir/src/main/java"
        def mainClasses = fileTree(dir: "${buildDir}/tmp/kotlin-classes/", includes: ["${uiTestBuildVariant}/**"], excludes: fileFilter)
        def javaClasses = fileTree(dir: "${buildDir}/intermediates/javac/", includes: ["${uiTestBuildVariant}/**"], excludes: fileFilter)

        sourceDirectories.from = files([mainSrc])
        classDirectories.from = files([mainClasses, javaClasses])
        executionData.from = fileTree(dir: "${buildDir}/outputs/code_coverage/${uiTestBuildVariant}AndroidTest/connected/", include: ["**.ec"])
    }


    /**
     * Generates a JaCoCo Report that aggregates the test coverage for the unit tests and
     * instrumentation tests. This will not have any task dependencies as the unit tests and
     * instrumentation tests should already have been run.
     *
     * We use the original source code but for the classes we use a combination of the debug and
     * release variants.
     *
     * - For the release variant we use all classes excluding the ui directory.
     * - For the debug variant we ONLY use the ui directory.
     */
    task jacocoCombinedUnitTestAndroidTestReport(type: JacocoReport) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for both UI and Unit Tests on the ${uiTestBuildVariantCapitalised} build."

        reports {
            xml.enabled = true
            html.enabled = true
        }

        def mainSrc = "$project.projectDir/src/main/java"
        def releaseKotlinClasses = fileTree(dir: "${buildDir}/tmp/kotlin-classes/${unitTestBuildVariant}", excludes: fileFilter + ["com/github/goldy1992/mp3player/client/ui**"])
        def debugKotlinClasses = fileTree(dir: "${buildDir}/tmp/kotlin-classes/${uiTestBuildVariant}/com/github/goldy1992/mp3player/client/ui/", excludes:fileFilter)
        def releaseJavaClasses = fileTree(dir: "${buildDir}/intermediates/javac/${unitTestBuildVariant}", excludes: fileFilter + ["com/github/goldy1992/mp3player/client/ui**"])
        def debugJavaClasses = fileTree(dir: "${buildDir}/intermediates/javac/${uiTestBuildVariant}/com/github/goldy1992/mp3player/client/ui/",excludes: fileFilter)

        def mainClasses = releaseKotlinClasses + debugKotlinClasses
        def javaClasses = releaseJavaClasses + debugJavaClasses

        sourceDirectories.from = files([mainSrc])
        classDirectories.from = files([mainClasses, javaClasses])
        executionData.from = fileTree(dir: buildDir, include: ["jacoco/test${unitTestBuildVariantCapitalised}UnitTest.exec",
                                                                    "outputs/code_coverage/${uiTestBuildVariant}AndroidTest/connected/**.ec"])
    }
}

private static List getBuildVariant(flavor, buildType) {
    def buildVariant =
            flavor.isBlank() ?
                buildType : "${flavor}${buildType.capitalize()}"
    [buildVariant, buildVariant.capitalize()]
}

static def getProductFlavor(applicableProductFlavor, productFlavors) {
    def flavor = ''
    if (!productFlavors?.isEmpty() && productFlavors.contains(applicableProductFlavor) ) {
        flavor = applicableProductFlavor
    }
    return flavor
}


